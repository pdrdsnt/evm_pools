use alloy::primitives::{U160, U256};
use alloy_provider::Provider;

use crate::{
    any_pool::V4Key,
    sol_types::V3Pool::V3PoolInstance,
    v3_base::{bitmap_math, states::V3State, trade::V3Trade},
};
pub struct V3Pool<P: Provider> {
    key: V4Key,
    state: V3State,
    contract: V3PoolInstance<P>,
}

impl<P: Provider> V3Trade for V3Pool<P> {
    fn trade(
        &mut self,
        amount: alloy::primitives::U256,
        from0: bool,
    ) -> Result<crate::v3_base::states::TradeState, crate::err::TradeError> {
        let state = &mut self.state;

        let fee = self.key.fee;

        match crate::v3_base::trade_math::trade_start(&state, &fee, amount, from0) {
            Ok(ok) => Ok(ok),
            Err(err) => Err(err),
        }
    }
    async fn sync(&mut self) -> Result<(), ()> {
        let state = self.contract.clone();
        let contract = &self.contract.clone();
        if let Ok(liquidity) = contract.liquidity().call().await {
            state.liquidity = U256::from(liquidity);
            if liquidity == 0 {
                return Err(());
            }
        }

        if let Ok(slot0) = contract.slot0().call().await {
            state.x96price = U256::from(slot0.sqrtPriceX96);
            state.tick = slot0.tick;

            if slot0.sqrtPriceX96 != U160::ZERO {
                return Ok(());
            }
        }
        Err(())
    }
    async fn update_v3_words(&mut self) -> Result<(), ()> {
        let tick_spacing = &self.key.tickSpacing;
        let contract = self.contract.clone();
        let state = &mut self.state;
        let w_idx = bitmap_math::word_index(bitmap_math::normalize_tick(
            state.tick,
            tick_spacing,
        ));

        let words_around = [
            w_idx - 1,
            w_idx,
            w_idx + 1,
        ];
        let mut active_ticks = Vec::<I24>::new();
        for word_idx in words_around {
            let mut bm = state
                .bitmap
                .get_word_from_tick(state.tick, tick_spacing);

            if bm.is_none() || update {
                if let Ok(bitmap) = contract.tickBitmap(word_idx).call().await {
                    bm = Some(bitmap);
                    state
                        .bitmap
                        .insert(word_idx, bitmap, tick_spacing);
                } else {
                    continue;
                };
            }

            if let Some(bitmap) = bm {
                let mut bitmap_ticks = bitmap_math::extract_ticks_from_bitmap(
                    bitmap,
                    word_idx,
                    tick_spacing,
                );
                active_ticks.append(&mut bitmap_ticks);
            }
        }
        Self::fetch_and_insert_v3_ticks(state, contract, active_ticks, update).await;

        Ok(())
    }
    pub async fn fetch_and_insert_v3_ticks(
        state: &mut V3State,
        contract: V3PoolInstance<P>,
        ticks: Vec<I24>,
        update: bool,
    ) {
        let mut fut = FuturesUnordered::from(
            ticks
                .iter()
                .filter_map(|x| {
                    let call = async { (x.clone(), contract.ticks(*x).call().await) };
                    if update {
                        //force update
                        return Some(call);
                    } else {
                        //try load first
                        if let Ok(tick) = state.ticks.get_tick(*x) {
                            if tick.liquidity_net.is_some() {
                                return None;
                            }
                            return Some(call);
                        }
                        None
                    }
                })
                .collect(),
        );
        let mut tcks = Vec::new();

        while let Some((tikc, tick_response)) = fut.next().await {
            let mut net = None;
            if let Ok(tr) = tick_response {
                net = Some(tr.liquidityNet);
            }

            let tick = Tick {
                tick: tikc,
                liquidity_net: net,
            };
            tcks.push(tick);
        }

        state.ticks.insert_ticks(tcks);
    }
}
